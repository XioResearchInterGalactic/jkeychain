apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'maven-publish'

group 'pt.davidafsilva.apple'
version '1.0.1-SNAPSHOT'
description = "Simple Java API to operate on OSX keychain generic passwords Edit"
sourceCompatibility = 1.8
targetCompatibility = 1.8

repositories {
    mavenCentral()
}

// add generated sources support
sourceSets {
    generated {
        java.srcDir "${buildDir}/generated-sources/"
    }
    main {
        compileClasspath += generated.output
        runtimeClasspath += generated.output
    }
    test {
        compileClasspath += generated.output
        runtimeClasspath += generated.output
    }
}

/**
 * Compiles the enums
 */
task compileEnumGenerator(type: Exec) {
    def libsDir = new File(buildDir, "libs")

    doFirst {
        libsDir.mkdirs()
    }

    commandLine 'gcc',
            '-arch',
            'arm64',
            '-arch',
            'x86_64',
            '-mmacosx-version-min=10.11',
            '-framework',
            'Security',
            '-std=c99',
            '-pedantic',
            '-Wall',
            '-o',
            "${libsDir}/generate_enums",
            "${projectDir}/src/main/c/generate_enums.c"
}

/**
 * Generates the enums Java code
 */
task generateEnums(type: Exec, dependsOn: compileEnumGenerator) {
    def genSourcesDir = new File(buildDir, "generated-sources/pt/davidafsilva/apple/")
    def authType = new File(genSourcesDir, 'OSXKeychainAuthenticationType.java').absolutePath
    def protocolType =  new File(genSourcesDir, 'OSXKeychainProtocolType.java').absolutePath
    doFirst {
        genSourcesDir.mkdirs()
    }

    commandLine "${buildDir}/libs/generate_enums", authType, protocolType
}
compileJava.dependsOn(generateEnums)

/**
 * Generates the JNI class headers
 */
task generateJniHeaders(type: JavaCompile, dependsOn: [generateEnums]) {
    classpath = sourceSets.main.compileClasspath
    destinationDir file("${buildDir}/generated/jni")
    source = sourceSets.main.java
    options.compilerArgs += [
            '-h', file("${projectDir}/src/main/c")
    ]
}

/**
 * Compiles the required SO library for the runtime
 */
task compileSoLibrary(type: Exec, dependsOn: generateJniHeaders) {
    def libsDir = new File(buildDir, "libs")

    doFirst {
        libsDir.mkdirs()
    }

    commandLine 'gcc',
            '-arch',
            'arm64',
            '-arch',
            'x86_64',
            '-mmacosx-version-min=10.11',
            '-dynamiclib',
            '-framework',
            'CoreFoundation',
            '-framework',
            'Security',
            '-I',
            '/Library/Java/JavaVirtualMachines/openjdk.jdk/Contents/Home/include',
            '-I',
            '/Library/Java/JavaVirtualMachines/openjdk.jdk/Contents/Home/include/darwin',
            '-std=c99',
            '-pedantic',
            '-Wall',
            '-o',
            "${libsDir}/osxkeychain.so",
            "${projectDir}/src/main/c/pt_davidafsilva_apple_OSXKeychain.c"
}
compileJava.finalizedBy(compileSoLibrary)

gradle.projectsEvaluated {
    jar {
        from sourceSets.generated.output
        from "${buildDir}/libs/osxkeychain.so"
        from("${projectDir}/LICENSE") {
            rename "LICENSE", "META-INF/LICENSE.txt"
        }
        manifest.attributes(
                "Name": rootProject.name,
                "Implementation-Title": rootProject.name,
                "Implementation-Version": archiveVersion,
                "Implementation-Vendor": "David Silva"
        )
    }
}

// copy SO to test classpath
task copySoLib(type: Copy)
copySoLib {
    from "${buildDir}/libs/"
    into test.testClassesDirs.singleFile
    include('osxkeychain.so')
}
testClasses.finalizedBy(copySoLib)

/**
 * Generates source jar
 */
task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource, sourceSets.generated.allSource
}

/**
 * Generates javadoc jar
 */
task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}
javadoc {
    source = sourceSets.main.allSource + sourceSets.generated.allSource
}
artifacts {
    archives sourcesJar
    archives javadocJar
}

dependencies {
    // test
    testImplementation 'junit:junit:4.13.2'
}

// Maven publishing support
publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            artifact sourcesJar
            artifact javadocJar
            pom.withXml {
                Node parent = asNode()

                // basic information
                parent.appendNode('name', project.name)
                parent.appendNode('description', project.description)
                parent.appendNode('url', 'https://github.com/davidafsilva/jkeychain')

                // license
                def licensesNode = new Node(parent, 'licenses')
                def licenseNode = new Node(licensesNode, 'license')
                licenseNode.appendNode("name", "BSD 2-Clause License")
                licenseNode.appendNode("url", "https://opensource.org/licenses/BSD-2-Clause")

                // developer
                def developersNode = new Node(parent, 'developers')
                def developerNode = new Node(developersNode, 'developer')
                developerNode.appendNode('id', 'davidafsilva')
                developerNode.appendNode('name', 'David Silva')
                developerNode.appendNode('email', 'david@davidafsilva.pt')
                developerNode.appendNode('organization', 'GitHub')
                developerNode.appendNode('organizationUrl', 'https://github.com/davidafsilva/')

                // scm
                def scmNode = new Node(parent, 'scm')
                scmNode.appendNode('connection', 'scm:git:git://github.com/davidafsilva/jkeychain.git')
                scmNode.appendNode('developerConnection', 'scm:git:git://github.com/davidafsilva/jkeychain.git')
                scmNode.appendNode('url', 'https://github.com/davidafsilva/jkeychain')
            }
        }
    }
}
